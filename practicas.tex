\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}	%Idioma
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx} 	%Añadir imágenes
\usepackage{geometry}	%Ajustar márgenes
\usepackage[export]{adjustbox}[2011/08/13]
\usepackage{float}
\restylefloat{table}
\usepackage[hidelinks]{hyperref} %Con opción para eliminar los bordes rojos
\usepackage{titling}
%\usepackage{minted}
\usepackage{multirow}
\usepackage{caption}
\usepackage{multicol}
\usepackage{array}
\selectlanguage{english}

%Para dibujar autómatas
\usepackage{tikz}
\usetikzlibrary{automata,positioning,arrows}

%Opciones de encabezado y pie de página:
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{}
\rhead{}
\lfoot{}
\cfoot{}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

%Opciones de fuente:
\usepackage[utf8]{inputenc}
\usepackage{sourcecodepro}
\usepackage[T1]{fontenc}

\setlength{\parindent}{15pt}
\setlength{\headheight}{15pt}
\setlength{\voffset}{10mm}

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

%Códigos fuente
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C,                 	   % the language of the code
  morekeywords={*,private},        % add more keywords to the set
  numbers=left,                    % where to put the line-numbers (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If 1, each line si numbered
  stringstyle=\color{magenta},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}
\begin{titlepage}

\begin{minipage}{\textwidth}

\centering
\includegraphics[width=0.6\textwidth]{/home/nazaret/Escritorio/LaTEX/logo.png}\\

\textsc{\Large Modelos de Computación\\[0.2cm]}
\textsc{GRADO EN INGENIERÍA INFORMÁTICA}\\[1cm]

{\Huge\bfseries Memoria de prácticas\\}
\noindent\rule[-1ex]{\textwidth}{3pt}\\[3.5ex]
{\large\bfseries}
\end{minipage}

\vspace{1.5cm}
\begin{minipage}{\textwidth}
\centering

\textbf{Autora}\\ {Nazaret Román Guerrero}\\[2.5ex]
\includegraphics[width=0.3\textwidth]{/home/nazaret/Escritorio/LaTEX/etsiit.jpeg}\\[0.1cm]
\vspace{1cm}
\textsc{Escuela Técnica Superior de Ingenierías Informática y de Telecomunicación}\\
\vspace{1cm}
\textsc{Curso 2018-2019}
\end{minipage}
\end{titlepage}

\pagenumbering{gobble}
\pagenumbering{arabic}
\tableofcontents
\thispagestyle{empty}

\newpage

\section{Práctica 1: Ejercicios prácticos sobre Lenguajes y Gramáticas}
\subsection{Ejercicio 1.} Calcula una gramática libre de contexto que genere el lenguaje $L=\{a^nb^mc^md^{2n}$ tal que $n,m\geq 0\}$.

\subsection{Ejercicio 2.} Describir una gramática que genere los números decimales escritos con el formato [signo][cifra][punto][cifra]. Por ejemplo, +3.45433, -453.23344, ...

\subsection{Ejercicio 3.} Calcula una gramática libre de contexto que genere el lenguaje $L=\{0^i1^j2^k$ tal que $i\not = j$ o $j\not = k\}$.

\subsection{Ejercicio 4.} Una empresa de videojuegos \textit{The fantastic platform} están planteando diseñar una gramática capaz de generar niveles de un juego de plataformas, cada uno de los niveles siguiendo las siguientes restricciones:
	\begin{itemize}
		\item Hay 2 grupos de enemigos: grupos grandes (\textit{g}) y grupos pequeños (\textit{p}).
		\item Hay 2 tipos de monstruos: fuertes (\textit{f}) y débiles (\textit{d}).
		\item
	\end{itemize}

\section{Anexo}
\subsection{Semana del 24 de septiembre de 2018}

\subsubsection{Ejercicio 1.} Describir el lenguaje generado por la siguiente gramática,\\
	\[S\rightarrow XYX \]
	\[X\rightarrow aX \mid bX \mid \varepsilon\]
	\[Y\rightarrow bbb\]
	
Esta gramática tiene los siguientes elementos definidos como:
	\[V=\{X,Y,S\}\]
	\[T=\{a,b\}\]
	\[S=\{S\}\]
	
Con los elementos anteriores y las producciones dadas, el lenguaje genera palabras que constan de una serie de símbolos $a$ ó $b$, seguidas por 3 símbolos $b$ consecutivos y por último, otra serie de símbolos $a$ ó $b$. Por ejemplo, se producen palabras como:

	\begin{itemize}
	\item $S\rightarrow XYX\rightarrow aXYaX\rightarrow aaXYabX \rightarrow aabXYXaba$
	\[Palabra_{producida}=aabbbbaba\]
	\item $S\rightarrow Y$ (utilizando $X\rightarrow \epsilon$)
	\[Palabra_{producida}=bbb\]
	\end{itemize}
	
Como hemos comprobado en los ejemplos anteriores, la expresión regular del lenguaje generado es:
	\[\mathcal{L}=(a+b)^{*}\cdot bbb\cdot (a+b)^{*}\]

\subsubsection{Ejercicio 2.} Describir el lenguaje generado por la siguiente gramática,\\
	\[S\rightarrow SS \mid XaXaX \mid \varepsilon \]
	\[X\rightarrow bX \mid \varepsilon\]
	
La gramática anterior tiene los elementos $S$, $V$ y $T$ definidos como:
	\[V=\{X,S\}\]
	\[T=\{a,b\}\]
	\[S=\{S\}\]
	
Con los elementos descritos y las producciones que se dan, el lenguaje genera palabras que constan de una serie (0 o más) de símbolos $b$, seguidos de un símbolo $a$, seguido de 0 o más símbolos $b$, sucedidos de otra $a$ y por último seguida por 0 o más $b$. Esta secuencia se puede repetir 0 o más veces. Por ejemplo, se producen palabras como:

	\begin{itemize}
	\item $S\rightarrow XaXaX\rightarrow bXabXa\rightarrow bbXaba\rightarrow bbbXaba$
	\[Palabra_{producida}=bbbaba\]
	\item $S\rightarrow \epsilon$
	\[Palabra_{producida}=\epsilon\]
	\item $S\rightarrow SS\rightarrow XaXaXS\rightarrow XaXaX\epsilon$ (sustituyendo las $X$ y la segunda $S$ por $\epsilon$)
	\[Palabra_{producida}=aa\]
	\end{itemize}
	
Por tanto, la expresión regular del lenguaje generado es:
	\[\mathcal{L}=(b^*\cdot a\cdot b^*\cdot a\cdot b^*)^*\]
	
\subsubsection{Ejercicio 3.} Piensa en un problema de la vida real en el que se pudiese aplicar los conocimientos vistos hoy en clase. Al igual que el ejemplo de la oficina de hoy, imagina y describe una gramática que se pueda utilizar para resolver dicho problema real.\\

Se puede hacer para un problema de logística donde se contronlen los caminos y las rutas por las que viajan los camiones/furgonetas. Para simplificar el problema, supondremos que hay, por ejemplo, cuatro rutas ($R$) posibles: $a$, $b$, $c$ y $d$, y que están conetadas entre ellas, es decir, que un camión puede comenzar desde la ruta inicial $i$ hacia, por ejemplo, la ruta $b$ y de ésta pasar a la ruta $d$, y que el camión puede repetir las rutas todas las veces que desee.\\

La gramática se define como sigue:

\[V=\{A,B,C,D,S\}\]
\[T=\{a,b,c,d,i\}\]
\[P=\{S\rightarrow iR\mid \epsilon,R\rightarrow aR\mid bR\mid cR\mid dR\mid \epsilon\}\]
\[S=\{S\}\]

\subsection{Semana del 1 de octubre de 2018}

\subsubsection{Ejercicio 4.} Encontrar si es posible una gramática lineal por la derecha o una gramática libre de contexto que genere el lenguaje L, en cada uno de los casos, supuesto que $L\subseteq {a,b,c}^{*}$ y verifica que:
	\begin{itemize}
	\item $u \in L$ si y solamente si verifica que $u$ no contiene dos símbolos $b$ consecutivos.
	
	La tupla $(V,T,P,S)$ se define así:
	
	\[V=\{S,X,Y\}\]
	\[T=\{a,b,c\}\]
	\[P=\{S\rightarrow X\mid bX\mid c\mid \epsilon,X\rightarrow aX\mid aY\mid \epsilon,Y\rightarrow bX\}\]
	\[S=\{S\}\]
	
	Con una grámatica con las producciones anteriores es imposible generar palabras con dos $b$ consecutivas, debido a que cada vez que se inserta una $b$, se obliga a utilizar inmediamente después la producción $X\rightarrow aX$ o la producción $X\rightarrow aY$, de forma que siempre se inserta una $a$ tras cada $b$. En este caso no he complicado más la gramática y practimente no he tenido en cuenta el símbolo $c$ exceptuando una cadena formada por una sola $c$ que surge de la producción $S$.
	
	\item $u \in L$ si y solamente si verifica que u contiene dos símbolos $b$ consecutivos.
	
	En este caso, la tupla $(V,T,P,S)$ que se forma es:
	
	\[V=\{S,X,Y,Z\}\]
	\[T=\{a,b,c\}\]
	\[P=\{S\rightarrow X\mid Y,X\rightarrow bXa\mid bXc\mid XY\mid YX\mid bZ\mid bZa\mid bZc,\]\[Y\rightarrow aYb\mid cYb\mid XY\mid YX,Z\rightarrow \epsilon\}\]
	\[S=\{S\}\]
	
	En este apartado todas las palabras que se crean están obligadas a tener dos o más $b$ consecutivas debido a las producciones de la gramática. En este caso, la producción $Y$ no tiene $\epsilon$ por lo que se ve obligada a volver a introducir una producción $X$. Ésta a su vez tiene que recurrir a una producción $Z$ que obliga a introducir 2 $b$ consecutivas.
	
	\item $u \in L$ si y solamente si verifica que contiene un número impar de símbolos $c$.
	
	La tupla $(V,T,P,S)$ que se forma es:
	
	\[V=\{S,X,Y,Z\}\]
	\[T=\{a,b,c\}\]
	\[P=\{S\rightarrow X\mid Y,X\rightarrow bXa\mid bXc\mid XY\mid YX\mid bZ\mid bZa\mid bZc,\]\[Y\rightarrow aYb\mid cYb\mid XY\mid YX,Z\rightarrow \epsilon\}\]
	\[S=\{S\}\]
	
	\end{itemize}

\subsection{Semana del 8 de octubre de 2018}

\subsubsection{Ejercicio 5.} ¿Qué lenguaje genera el siguiente autómata?

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,scale = 1,transform shape]
	\node[state,initial,accepting] (q0)   {$q_0$}; 
	\node[state,accepting] (q1) [right=of q0] {$q_1$}; 
	\node[state] (q2) [right=of q1] {$q_2$};
	
	\draw 	(q0) edge[loop above] node{0} (q0)
			(q0) edge[above] node{1} (q1)
			(q1) edge[above] node{0} (q2)
			(q1) edge[loop above] node{1} (q1)
			(q2) edge[loop above] node{0,1} (q2);
\end{tikzpicture}
\end{figure}

El anterior autómata produce cadenas que solo contienen 0 o que contienen 0 y 1 y acaban en 1. En el caso de que la cadena contenga 0 y 1 contenga 0 después del último 1, no se acepta. La expresión regular del lenguaje es:
	\[\mathcal{L}=(0+1)^{*}\cdot 1\]

\subsubsection{Ejercicio 6.} Sea $M = (Q, {0,1},q_0,\delta,F)$, diseñar el autómata \textit{M} en los siguientes casos:
	\begin{enumerate}
	\item que reconozca todas las palabras que \textbf{no} empiezan por 00.
	\item que reconozca todas las palabras que \textbf{no} empiezan por 00, pero \textbf{sí} contengan 00.
	\item diseñar el autómata que acepte las palabras que rechaza el AFD anterior.
	\end{enumerate}	
	
Definir para dichos autómata $Q$, $q_0$, $\delta$, $F$.\\

	\begin{enumerate}
	\item Primer autómata
		\[Q=\{q_0,q_1,q_2,q_3\}\]
		\[A=\{0,1\}\]
		\[estado_{inicial}=q_0\]
		\[\delta=
			\begin{bmatrix}
    			(q_0,0)=q_1 & (q_1,0)=q_3 & (q_2,0)=q_1 & (q_3,0)=q_3 \\
    			(q_0,1)=q_0 & (q_1,1)=q_2 & (q_2,1)=q_2 & (q_3,1)=q_3 \\
			\end{bmatrix}
		\]
		\[F=\{q_0,q_1,q_2\}\]
		
	\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,scale = 1,transform shape]
		\node[state,initial,accepting] (q0)   {$q_0$}; 
		\node[state,accepting] (q1) [right=of q0] {$q_1$}; 
		\node[state,accepting] (q2) [below=of q1] {$q_2$};
		\node[state] (q3) [right=of q1] {$q_3$};
	
		\draw 	(q0) edge[loop above] node{1} (q0)
				(q0) edge[above] node{0} (q1)
				(q1) edge[above] node{0} (q3)
				(q1) edge[bend left,right] node{1} (q2)
				(q2) edge[loop below] node{1} (q2)
				(q2) edge[bend left,left] node{0} (q1)
				(q3) edge[loop above] node{0,1} (q3);
	\end{tikzpicture}
	\end{figure}
	
	\item Segundo autómata
		\[Q=\{q_0,q_1,q_2,q_3\}\]
		\[A=\{0,1\}\]
		\[estado_{inicial}=q_0\]
		\[\delta=
			\begin{bmatrix}
    			(q_0,0)=q_1 & (q_1,0)=q_3 & (q_2,0)=q_2 & (q_3,0)=q_3 \\
    			(q_0,1)=q_0 & (q_1,1)=q_2 & (q_2,1)=q_2 & (q_3,1)=q_3 \\
			\end{bmatrix}
		\]
		\[F=\{q_0,q_1,q_2\}\]
		
	\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,scale = 1,transform shape]
		\node[state,initial,accepting] (q0)   {$q_0$}; 
		\node[state,accepting] (q1) [right=of q0] {$q_1$}; 
		\node[state,accepting] (q2) [below=of q1] {$q_2$};
		\node[state] (q3) [right=of q1] {$q_3$};
	
		\draw 	(q0) edge[loop above] node{1} (q0)
				(q0) edge[above] node{0} (q1)
				(q1) edge[above] node{0} (q3)
				(q1) edge[right] node{1} (q2)
				(q2) edge[loop below] node{0,1} (q2)
				(q3) edge[loop above] node{0,1} (q3);
	\end{tikzpicture}
	\end{figure}
	
	\item Tercer autómata
		\[Q=\{q_0,q_1,q_2,q_3\}\]
		\[A=\{0,1\}\]
		\[estado_{inicial}=q_0\]
		\[\delta=
			\begin{bmatrix}
    			(q_0,0)=q_1 & (q_1,0)=q_3 & (q_2,0)=q_2 & (q_3,0)=q_3 \\
    			(q_0,1)=q_0 & (q_1,1)=q_2 & (q_2,1)=q_2 & (q_3,1)=q_3 \\
			\end{bmatrix}
		\]
		\[F=\{q_0,q_1,q_2\}\]
		
	\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,scale = 1,transform shape]
		\node[state,initial] (q0)   {$q_0$}; 
		\node[state] (q1) [right=of q0] {$q_1$}; 
		\node[state,accepting] (q2) [right=of q1] {$q_2$};
		\node[state,accepting] (q3) [below=of q2] {$q_3$};
		\node[state] (q4) [below=of q1] {$q_4$};
	
		\draw 	(q0) edge[above] node{1} (q4)
				(q0) edge[above] node{0} (q1)
				(q1) edge[above] node{0} (q2)
				(q1) edge[right] node{1} (q4)
				(q2) edge[loop above] node{1} (q2)
				(q2) edge[bend left, right] node{0} (q3)
				(q3) edge[bend left,    left] node{1} (q2)
				(q3) edge[above] node{0} (q4)
				(q4) edge[loop below] node{0,1} (q4);
	\end{tikzpicture}
	\end{figure}
		
	\end{enumerate}

\subsection{Semana del 15 de octubre de 2018}

\subsubsection{Ejercicio 7.} Diseñar un autómata que acepte los siguientes lenguajes. En todos los casos, en el alfabeto {0,1}.
	\begin{enumerate}
	\item Lenguaje que acepta las cadenas de mínima longitud 2, cuyos 				primeros símbolos son el mismo.
	
	\[Q=\{q_0,q_1,q_2,q_3\}\]
	\[A=\{0,1\}\]
	\[estado_{inicial}=q_0\]
	\[\delta=
		\begin{bmatrix}
    		(q_0,0)=q_1 & (q_1,0)=q_2 & (q_2,0)=q_2 & (q_3,0)=q_4 & (q_4,0)=q_4\\
    		(q_0,1)=q_3 & (q_1,1)=q_4 & (q_2,1)=q_2 & (q_3,1)=q_2 & (a_4,1)=q_4\\
		\end{bmatrix}
	\]
	\[F=\{q_2\}\]
		
	\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,scale = 1,transform shape]
		\node[state,initial] (q0) {$q_0$}; 
		\node[state] (q1) [right=of q0] {$q_1$}; 
		\node[state,accepting] (q2) [right=of q1] {$q_2$};
		\node[state] (q3) [below=of q0] {$q_3$};
		\node[state] (q4) [below =of q2] {$q_4$};
	
		\draw 	(q0) edge[left] node{1} (q3)
				(q0) edge[above] node{0} (q1)
				(q1) edge[above] node{0} (q2)
				(q1) edge[right] node{1} (q4)
				(q2) edge[loop right] node{0,1} (q2)
				(q3) edge[below] node{0} (q4)
				(q3) edge[above] node{1} (q2)
				(q4) edge[loop right] node{0,1} (q4);
	\end{tikzpicture}
	\end{figure}
	
	\item Lenguaje cuyas cadenas tienen una longitud mínima de 2, y cuyo 			últimos símbolos son los mismos.
	
	\[Q=\{q_0,q_1,q_2,q_3\}\]
	\[A=\{0,1\}\]
	\[estado_{inicial}=q_0\]
	\[\delta=
		\begin{bmatrix}
    		(q_0,0)=\{q_0,q_1\} & (q_1,0)=q_2 & (q_2,0)=q_2 & (q_3,0)=q_4 & (q_4,0)=q_4\\
    		(q_0,1)=\{q_0,q_3\} & (q_1,1)=q_4 & (q_2,1)=q_2 & (q_3,1)=q_2 & (a_4,1)=q_4\\
		\end{bmatrix}
	\]
	\[F=\{q_2\}\]
		
	\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,scale = 1,transform shape]
		\node[state,initial] (q0) {$q_0$}; 
		\node[state] (q1) [right=of q0] {$q_1$}; 
		\node[state,accepting] (q2) [right=of q1] {$q_2$};
		\node[state] (q3) [below=of q0] {$q_3$};
		\node[state] (q4) [below =of q2] {$q_4$};
	
		\draw 	(q0) edge[left] node{1} (q3)
				(q0) edge[above] node{0} (q1)
				(q0) edge[loop above] node{0,1} (q0)
				(q1) edge[above] node{0} (q2)
				(q1) edge[right] node{1} (q4)
				(q3) edge[below] node{0} (q4)
				(q3) edge[above] node{1} (q2)
				(q4) edge[loop right] node{0,1} (q4);
	\end{tikzpicture}
	\end{figure}
	\end{enumerate}
	
\subsubsection{Ejercicio 8.} Autómata con un número impar de 0 y con un número impar de 1.

	\[Q=\{q_0,q_1,q_2\}\]
	\[A=\{0,1\}\]
	\[estado_{inicial}=q_0\]
	\[\delta=
		\begin{bmatrix}
    		(q_0,0)=q_1 & (q_1,0)=q_0 & (q_2,0)=q_1 \\
    		(q_0,1)=q_3 & (q_1,1)=q_3 & (q_2,1)=q_0 \\
		\end{bmatrix}
	\]
	\[F=\{q_0\}\]
		
	\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.5cm,scale = 1,transform shape]
		\node[state,initial,accepting] (q0)   {$q_0$}; 
		\node[state] (q1) [right=of q0] {$q_1$}; 
		\node[state] (q2) [below right=of q0] {$q_2$};
	
		\draw 	(q0) edge[bend left,above] node{0} (q1)
				(q0) edge[right] node{1} (q2)
				(q1) edge[below] node{0} (q0)
				(q1) edge[bend left,right] node{1} (q2)
				(q2) edge[bend left, left] node{1} (q0)
				(q2) edge[left] node{0} (q1);
	\end{tikzpicture}
	\end{figure}

\subsubsection{Ejercicio 9.} Diseñar un AFND para los siguientes lenguajes. \textbf{\underline{Cada AFND debería respetar el }} \textbf{\underline{número de estados y de transiciones}}. Cada transición con 2 símbolos cuenta como dos transciones. En todos los casos el alfabeto es {0,1}.
	\begin{enumerate}
	\item $L$ acepta las cadenas de longitud mayor o igual que 2 que empiezan en 0 y terminan en 1. No más de 3 estados y 4 transiciones.
	
	\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node 			distance=2cm,scale = 1,transform shape]
		\node[state,initial] (q0) {$q_0$}; 
		\node[state] (q1) [right=of q0] {$q_1$}; 
		\node[state,accepting] (q2) [right=of q1] {$q_2$};
	
		\draw 	(q0) edge[above] node{0} (q1)
				(q1) edge[above] node{1} (q2)
				(q1) edge[loop above] node{0,1} (q1);
		\end{tikzpicture}
	\end{figure}
	
	\item $L$ es el lenguaje que contiene las adenas cuya longitud es al menos 2 y que sus dos últimos símbolos son el mismo. No más de 4 estados y 6 transiciones.
	
	\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node 			distance=2cm,scale = 1,transform shape]
		\node[state,initial] (q0) {$q_0$}; 
		\node[state] (q1) [right=of q0] {$q_1$}; 
		\node[state,accepting] (q2) [right=of q1] {$q_2$};
		\node[state] (q3) [below= of q1] {$q_3$};
	
		\draw 	(q0) edge[above] node{0} (q1)
				(q0) edge[loop above] node{0,1} (q0)
				(q0) edge[left] node{1} (q3)
				(q1) edge[above] node{0} (q2)
				(q3) edge[right] node{1} (q2);
		\end{tikzpicture}
	\end{figure}
	
	\item $L$ es el lenguaje cuyas cadenas son al menos de longitud 2 y que tienen un 1 en la penúltima posición. No más de 3 estados y 5 transciones.
	
	\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node 			distance=2cm,scale = 1,transform shape]
		\node[state,initial] (q0) {$q_0$}; 
		\node[state] (q1) [right=of q0] {$q_1$}; 
		\node[state,accepting] (q2) [right=of q1] {$q_2$};
	
		\draw 	(q0) edge[above] node{1} (q1)
				(q0) edge[loop above] node{0,1} (q0)
				(q1) edge[above] node{0,1} (q2);
		\end{tikzpicture}
	\end{figure}
	
	\end{enumerate}

\subsection{Semana del 22 de octubre de 2018}

\subsubsection{Ejercicio 10.} Pasar a un autómata finito determinista:

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,scale = 1,transform shape]
	\node[state,initial] (s0) {$s_0$}; 
	\node[state,accepting] (s1) [right=of s0] {$s_1$}; 
	\node[state] (s2) [below right=of s0] {$s_2$};
	
	\draw 	(s0) edge[loop above] node{a,b} (s0)
			(s0) edge[above] node{a} (s2)
			(s1) edge[bend right, above] node{b} (s0)
			(s1) edge[loop above] node{a} (s1)
			(s2) edge[right] node{a,b} (s1);
\end{tikzpicture}
\end{figure}

\subsubsection{Ejercicio 11.} Pasar a AFD

\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,scale = 1,transform shape]
	\node[state,initial] (s0) {$s_0$}; 
	\node[state] (s2) [right=of s0] {$s_2$};
	\node[state,accepting] (s1) [right=of s2] {$s_1$}; 
	\node[state] (s3) [below=of s2] {$s_3$};
	
	\draw 	(s0) edge[loop above] node{a} (s0)
			(s0) edge[above] node{a} (s2)
			(s0) edge[left] node{$\epsilon$} (s3)
			(s1) edge[bend right, above] node{b} (s0)
			(s1) edge[loop above] node{a} (s1)
			(s2) edge[above] node{a,b} (s1)
			(s3) edge[right] node{b} (s1);
\end{tikzpicture}
\end{figure}

Para poder hacer el AFD, rellenamos la tabla con los estados para saber qué nuevos estados se crearán en el AFD.

El procedimiento a seguir es el siguiente: se extraen por ejemplo los estados de $s_0$ a los que le entra una $a$ y se comprueba a qué estados se desplazan dichos estados cuando les entra el mismo símbolo. De ahí se crea un estado con el conjunto de los estados anteriores. Si alguno de los estados de este conjunto es final, el estado resultante también lo es. Debajo de la tabla se muestra el diseño del AFD siguiendo este procedimiento.

	\begin{figure}[H]
	\centering
	\begin{tabular}{|c|c c|}
		\hline
			 & a & b \\
		\hline
			$s_0$ & $\{s_0,s_2,s_3\}$ & $\{s_0,s_1\}$ \\
			$s_1$ & $s_1$ & $s_0$ \\
			$s_2$ & $s_1$ & $s_1$ \\
			$s_3$ & $s_0$ & $s_1$ \\
		\hline
	
	\end{tabular}
	\end{figure}
	
\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,scale = 1,transform shape]
	\node[state,initial] (s0) {$\{s_0,s_2,s_3\}$};
	\node[state,accepting] (s1) [right=of s0] {$\{s_0,s_1\}$}; 
	\node[state,accepting] (s2) [right=of s1] {$\{s_0,s_1,s_2,s_3\}$};
	
	\draw 	(s0) edge[loop above] node{a} (s0)
			(s0) edge[above] node{b} (s1)
			(s1) edge[above] node{a} (s2)
			(s1) edge[loop above] node{b} (s1)
			(s2) edge[loop above] node{a,b} (s2);
\end{tikzpicture}
\end{figure}	

\subsection{Semana del 29 de octubre de 2018}

\subsubsection{Ejercicio 12.} Diseñar un autómata finito de estados que dada una entrada en el alfabeto {0,1}, escriba en la salida 1 si encuentra el patrón de entrada 101, en caso contrario que escriba 0.
	\begin{enumerate}
	\item Realizar el diseño del autómata en papel.
	\item Implementar dicho autómata en el lenguaje de 				programación que se desee.
	\end{enumerate}
	
El desarrollo del ejercicio es el que sigue:
	
	\begin{enumerate}
	\item Para diseñar el autómata, se tiene en cuenta que se escribe 1 cada vez que encuentra la secuencia 101, y 0 en el resto de casos; por tanto, el diseño del autómata es el siguiente:
	
	\begin{figure}[H]
	\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node 							distance=2cm,scale = 1,transform shape]
		\node[state,initial] (q0) {$q_0$}; 
		\node[state] (q1) [right=of q0] {$q_1$};
		\node[state] (q2) [right=of q1] {$q_2$}; 
		\node[state] (q3) [right=of q2] {$q_3$};
	
		\draw 	(q0) edge[loop above] node{0,1/0} (s0)
				(q0) edge[above] node{1/0} (q1)
				(q1) edge[above] node{0/0} (q2)
				(q2) edge[above] node{1/1} (q3)
				(q3) edge[bend right, above] node{1/0} (q1)
				(q3) edge[loop right] node{0,1/0} (q3);
		\end{tikzpicture}
	\end{figure}	
	
	\item El código en C++ es el siguiente:
	\begin{lstlisting}
	while(true)
	{
		// Se busca la secuencia
		if(in[i] == '1' && in[i+1] == '0' && in[i+2] == '1') 
			out[j] = 1;

		else 
			out[j] = 0;

		// Se aumentan los indices de entrada y salida
		i++;
		j++;
	}
	\end{lstlisting}
	\end{enumerate}
	
\subsubsection{Ejercicio 13.} Diseñar un autómata finito de estados con una salida y con una entrada. La salida se pone a 'x' cuando al menos ha encontrado dos '1' y dos '0' en la entrada, sin importar el orden de aparición.\\

Este autómata se va a diseñar con forma de matriz de manera que se vea claramente el funcionamiento. Cuando no se cumplen las condiciones, se escribe $y$ en la salida. Una vez conseguidas las condiciones, se escribe $x$ en la salida. El diseño es este:

	\begin{figure}[H]
	\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node 							distance=2cm,scale = 1,transform shape]
		\node[state,initial] (00) {$00$}; 
		\node[state] (01) [right=of 00] {$01$};
		\node[state] (02) [right=of 01] {$02$};
		\node[state] (10) [below=of 00] {$10$};
		\node[state] (11) [below=of 01] {$11$};
		\node[state] (12) [below=of 02] {$12$};
		\node[state] (20) [below=of 10] {$20$};
		\node[state] (21) [below=of 11] {$21$}; 
		\node[state] (22) [below=of 12] {$22$};
	
		\draw 	(00) edge[above] node{1/y} (01)
				(00) edge[left] node{0/y} (10)
				(01) edge[above] node{1/y} (02)
				(01) edge[left] node{0/y} (11)
				(02) edge[right] node{0/y} (12)
				(10) edge[above] node{1/y} (11)
				(10) edge[left] node{0/y} (20)
				(11) edge[above] node{1/y} (12)
				(11) edge[left] node{0/y} (21)
				(12) edge[right] node{0/x} (22)
				(20) edge[above] node{1/y} (21)
				(21) edge[above] node{1/x} (22)
				(22) edge[loop right] node{0,1/x} (22);
				
		\end{tikzpicture}
	\end{figure}

\end{document}